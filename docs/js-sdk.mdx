---
title: 'JS SDK'
order: 30
---

## JS SDK

Through Yorkie JS SDK, you can efficiently build collaborative applications. On the client-side implementation, you can create Documents that are automatically synced with remote peers with minimal effort.

If you want to install the SDK, refer to the [Getting Started with JS SDK](/docs/getting-started/with-js-sdk).

### Client

`Client` is a normal client that can communicate with the server. It has documents and sends changes of the document from local to the server to synchronize with other replicas in remote.

#### Creating a Client

We can create a Client using `new yorkie.Client()`. After the Client has been activated, it is connected to the server and ready to use.

```javascript
const client = new yorkie.Client('{{API_ADDR}}', {
  apiKey: 'xxxxxxxxxxxxxxxxxxxx',
});
await client.activate();
```

> The API key is used to identify the project in Yorkie. You can get the API key of the project you created in the [Dashboard]({{DASHBOARD_PATH}}).

#### Subscribing to Client events

We can use `client.subscribe` to subscribe to client-based events, such as `status-changed`, `stream-connection-status-changed` and `peer-changed`.

```javascript
const unsubscribe = client.subscribe((event) => {
  if (event.type === 'status-changed') {
    console.log(event.value); // 'activated' or 'deactivated'
  } else if (event.type === 'stream-connection-status-changed') {
    console.log(event.value); // 'connected' or 'disconnected'
  }
});
```

By using the value of the `stream-connection-status-changed` event, it is possible to determine whether the Client is connected to the network.

If you want to know about other client events, please refer to the [ClientEvent](https://yorkie.dev/yorkie-js-sdk/api-reference/yorkie-js-sdk.clientevent), and [ClientEventType](https://yorkie.dev/yorkie-js-sdk/api-reference/yorkie-js-sdk.clienteventtype).

#### Presence

Presence is a feature that allows you to display information about users who are currently using a collaborative application. Presence is often used in collaborative applications such as document editors, chat apps, and other real-time applications.

```javascript
const clientA = new yorkie.Client('{{API_ADDR}}', {
  presence: {
    username: 'alice',
    color: 'blue',
  },
});
await clientA.activate();

const docA = new yorkie.Document('doc-1');
await clientA.attach(docA);
```

Then, another Client is created and attaches a Document with the same name as before.

```javascript
const clientB = new yorkie.Client('{{API_ADDR}}', {
  presence: {
    username: 'bob',
    color: 'red',
  },
});
await clientB.activate();

const docB = new yorkie.Document('doc-1');
await clientB.attach(docB);
```

When a new peer registers or leaves, the `peers-changed` event is fired, and the other peer's clientID and presence can be obtained from the event.

```javascript
const unsubscribe = clientA.subscribe((event) => {
  if (event.type === 'peers-changed') {
    const peers = event.value.peers[doc.getKey()];
    switch (event.value.type) {
      case 'initialized':
        displayPeers(peers);
        break;
      case 'watched':
        peers.forEach((peer) => addPeer(peer));
        // peer as follows:
        // {
        //   clientID: 'xxxxxxxxxxxxxxxxxxxx',
        //   presence: {username: 'bob', color: 'red'}
        // }
        break;
      case 'unwatched':
        peers.forEach((peer) => removePeer(peer));
        break;
      case 'presence-changed':
        peers.forEach((peer) => updatePeer(peer));
        break;
      default:
        break;
    }
  }
});
```

In the code above, `clientA` receives a `watched` event from `clientB` because `clientB` attached the Document with the key `doc-1`.

Presence can include their names, colors, and other identifying details. Here is an example of how Presence might be used in a collaborative document editor:
- [Profile Stack](/examples/profile-stack)

### Document

`Document` is a primary data type in Yorkie, which provides a JSON-like updating experience that makes it easy to represent your application's model. A `Document` can be updated without being attached to the client, and its changes are automatically propagated to other peers when the `Document` is attached to the `Client` or when the network is restored.

#### Creating a Document

We can create a Document using `yorkie.Document()`. Let's create a Document with a key and attach it to the Client.

```javascript
const doc = new yorkie.Document('doc-1');
await client.attach(doc);
```

> The document key is used to identify the Document in Yorkie. It is a string that can be freely defined by the user. However, it is allowed to use only `a-z`, `A-Z`, `0-9`, `-`, `.`, `_`, `~` and must be less than 120 characters.

After attaching the Document to the Client, all changes to the Document are automatically synchronized with remote peers.

#### Changing Syncronization Setting

To change the synchronization setting for a document, you can use `client.pause(doc)` and `client.resume(doc)`.

When you pause a document, the synchronization process will no longer occur in realtime, and you will need to manually execute the synchronization to ensure that the changes are propagated to other clients.

To resume the realtime synchronization, you can call `client.resume(doc)`.

```javascript
// Pause real-time sync
await client.pause(doc);

// Resume real-time sync
await client.resume(doc);
```

#### Changing Syncronization Mode

By default, Yorkie synchronizes a document in `push-pull` mode, where local changes are pushed to the server, and remote changes are pulled from the server.

If you only want to send your changes and not receive remote changes, you can use `push-only` mode.

For realtime synchronization, you can use `client.pauseRemoteChanges(doc)` and `client.resumeRemoteChanges(doc)`.

For manual synchronization, you can pass the desired sync mode to `client.sync(doc, syncMode)`.

```javascript
// Pause remote changes for realtime sync
client.pauseRemoteChanges(doc);
// Resume remote changes for realtime sync
client.resumeRemoteChanges(doc);

// Manual sync in Push-Only mode
await client.sync(doc, SyncMode.PushOnly);
// Manual sync in Push-Pull mode
await client.sync(doc, SyncMode.PushPull);
```

#### Editing the Document

`Document.update(changeFn, message)` enables you to modify a Document. The optional `message` allows you to add a description to the change. If the Document is attached to the Client, all changes are automatically synchronized with other Clients.

```javascript
const message = 'update document for test';
doc.update((root) => {
  root.todos = [];
  root.todos.push('todo-1');
  root.obj = {
    name: 'yorkie',
    age: 14,
  };
  root.counter = new yorkie.Counter(yorkie.IntType, 0);
  root.counter.increase(1);
}, message);
```

Under the hood, `root` in the `update` function creates a `change`, a set of operations, using a JavaScript proxy. Every element has its unique ID, created by the logical clock. This ID is used by Yorkie to track which object is which.

You can get the contents of the Document using `document.getRoot()`.

```javascript
const root = doc.getRoot();
console.log(root.todos);    // ["todo-1"]
console.log(root.obj);      // {"name":"yorkie","age":14}
console.log(root.obj.name); // "yorkie"
console.log(root.counter.getValue()); // 1
```

#### Subscribing to Document events

A Document can be modified by changes generated remotely or locally in Yorkie.

Whenever the Document is modified, change events are triggered and we can subscribe to these events using the `document.subscribe(callback)`.

The callback is called with an event object, and the `event.type` property indicates the source of the change, which can be one of the following values: `local-change`, `remote-change`, or `snapshot`.

When the `event.type` is `local-change` or `remote-change`, the `event.value` is a list of changeInfo.
Each changeInfo is an `{operations, message}` object.

For more information about changeInfo for document events, please refer to the [ChangeInfo](https://yorkie.dev/yorkie-js-sdk/api-reference/yorkie-js-sdk.remotechangeevent.html).


```javascript
const unsubscribe = doc.subscribe((event) => {
  if (event.type === 'local-change') {
    console.log(event);
  } else if (event.type === 'remote-change') {
    for (const changeInfo of event.value) {
      // `message` delivered when calling document.update
      const { message, operations } = changeInfo;
      for (const op of operations) {
        // ex) { type: 'increase', value: 1, path: '$.counter' }
        switch (op.type) {
          case 'increase':
            // Do something...
            break;
        }
      }
    }
  }
});
```

Additionally, you can subscribe to changes for a specific path in the Document using `doc.subscribe(path, callback)` with a path argument, such as `$.todos`, where the `$` sign indicates the root of the document.
The callback function is called when the target path and its nested values are changed.

```javascript
const unsubscribe = doc.subscribe('$.todos', (event) => { 
  // The callback will be called when the root.todos or any of its nested values change.
  const target = doc.getValueByPath('$.todos') // you can get the value by path 
  // Do something...
});
```

#### Detaching the Document

If the document is no longer used, it should be detached to increase the efficiency of GC removing [CRDT tombstones](https://crdt.tech/glossary). For more information about GC, please refer to [Garbage Collection](https://github.com/yorkie-team/yorkie/blob/main/design/garbage-collection.md).

```javascript
await client.detach(doc);
```

### Custom CRDT types

Custom CRDT types are data types that can be used for special applications such as text editors and counters, unlike general JSON data types such as `Object` and `Array`. Custom CRDT types can be created in the callback function of `document.update`.

#### Text

`Text` provides supports for collaborative text editing. `Text` has selection information for sharing the cursor position. In addition, contents in `Text` can have attributes; for example, characters can be bold, italic, or underlined.

```javascript
doc.update((root) => {
  root.text = new yorkie.Text();            // {"text":""}
  root.text.edit(0, 0, 'hello');            // {"text":"hello"}
  root.text.edit(0, 1, 'H');                // {"text":"Hello"}
  root.text.select(0, 1);                   // {"text":"^H^ello"}
  root.text.setStyle(0, 1, { bold: true }); // {"text":"<b>H</b>ello"}
});
```

An example of Text co-editing with CodeMirror: [CodeMirror example](https://github.com/yorkie-team/yorkie-js-sdk/blob/main/examples/vanilla-codemirror6)

An example of Text co-editing with Quill: [Quill example](https://github.com/yorkie-team/yorkie-js-sdk/blob/main/examples/vanilla-quill)

#### Counter

`Counter` supports integer types changing with addition and subtraction. If an integer data needs to be modified simultaneously, `Counter` should be used instead of primitives.

```javascript
doc.update((root) => {
  root.counter = new yorkie.Counter(yorkie.IntType, 1); // {"counter":1}
  root.counter.increase(2);                             // {"counter":3}
  root.counter.increase(3);                             // {"counter":6}
  root.counter.increase(-4);                            // {"counter":2}
});
```

### TypeScript Support

To use the Document more strictly, we can use [type variable](https://www.typescriptlang.org/docs/handbook/2/generics.html) in TypeScript when creating a Document.

```typescript
type DocType = {
  list: Array<number>;
  text: yorkie.Text;
};

const doc = new yorkie.Document<DocType>('key');
doc.update((root) => {
  root.list = [1, 2, 3];
  root.text = new yorkie.Text();
});
```

### Reference

For details on how to use the JS SDK, please refer to [JS SDK Reference](https://yorkie.dev/yorkie-js-sdk/api-reference/).
